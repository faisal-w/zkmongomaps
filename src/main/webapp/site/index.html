<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
 | Generated by Apache Maven Doxia at Dec 29, 2012
 | Rendered using Apache Maven Fluido Skin 1.2.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maven - Serverside Pagination with ZK, Spring Data MongoDB and Google Maps</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido.min.js"></script>

    
    <meta http-equiv="Content-Language" content="en" />
    $headContent
        </head>
        <body class="topBarDisabled">
          
                        
                    
    
        <div class="container">
          <div id="banner">
        <div class="pull-left">
                                                  <a href=".." id="bannerLeft">
                                                                                        <img src="https://secure.gravatar.com/avatar/92ab9af5b2597efeee9eab0f0d782409"  alt="ZkToDo2"/>
                </a>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
            
                  <li id="publishDate">Last Published: 2012-12-29</li>
                  <li class="divider">|</li> <li id="projectVersion">Version: 1.0</li>
                      
                
            
      
                                  
    <li class="pull-right">              <a href=".." title="simbo1905">simbo1905</a>
  </li>

                        </ul>
      </div>

      
        <div id="bodyColumn" >
                                  
            <div class="section"><h2>Introduction</h2>
<p>Handling large data sets efficiently can be critical in creating a responsive application. An standard strategy is to delegate the pagination of the data to the database known as &quot;serverside pagination&quot;. Traditionally this would require writing a significant amount of boilerplate code. This article will combine ZK MVVM, Spring Data MongoDB and Google Maps to browse a zipcode dataset efficiently with very little code. </p>
<p>The sample sourcecode is available on Github at <a href="https://github.com/simbo1905/zkmongomaps" class="externalLink">zkmongomaps</a> and the application can be viewed running on the <a href="http://zkmongomaps-simbo1905.rhcloud.com/" class="externalLink">openshift</a> cloud.</p>
</div>
<div class="section"><h2>The Screen</h2>
<p>The screen is a Google Maps component driven by a paginated listbox: </p>
<img src="./images/screen.png" alt="Sample Screen" /><p>The screen renders simple Zipcode entities which are defined within the file <a href="https://github.com/simbo1905/zkmongomaps/blob/master/src/main/java/org/github/simbo1905/zkmongogmaps/app/Zipcode.java" class="externalLink">Zipcode.java</a> outlined below: </p>
<div class="source"><pre class="prettyprint">
        08 @Document
        09 public class Zipcode {
        10      @Id
        11      private String _id;
        12      
        13      private int pop = 0;
        14      
        15      private String state = null;
        16      
        17      private double[] loc;
        18 
        19      private String city;
        
                // getters, setters, constructors
                
                // expose mongo geospacial pair as simple properties for screen
        
        72      public double[] getLoc() {
        73              return loc;
        74      }
        75 
        76      public float getLng() {
        77              return (float) loc[0];
        78      }
        79 
        80      public float getLat() {
        81              return (float) loc[1];
        82      }
        83 
        84      public void setLat(float lat) {
        85              loc[1] = lat;
        86      }

</pre>
</div>
<p>The entity class is marked with Spring Data persistence annotations <tt>@Document</tt> and <tt>@Id</tt>. This marks the entity for mapping into the MongoDB document database and defines the document primary key. The remainder of the class defines simple properties that Spring Data MongoDb will map to documents using reflection. </p>
</div>
<div class="section"><h2>Data Access</h2>
<p>The data access layer is provided by a single file which defines the ZipcodeRepository interface. No implementation of the class is given within the sample sourcecode; the Spring Data MongoDB framework generates an implementation at runtime. </p>
<div class="source"><pre class="prettyprint">
        @Repository
        public interface ZipcodeRepository extends MongoRepository&lt;Zipcode, String&gt; {
        }
</pre>
</div>
<p><tt>MongoRepository</tt> extends both <tt>CrudRepository</tt> and <tt>PagingAndSortingRepository</tt> for basic data access and paging behaviour. It is the generated class which provides all the CRUD and pagination logic used in the sample sourcecode including the <tt>findAll</tt> method used by the screen:</p>
<div class="source"><pre class="prettyprint">
        Page&lt;T&gt; findAll(Pageable pageable);
</pre>
</div>
<p>Better yet the Spring Data MongoDB framework can generate custom query logic based on carefully named method signatures. Within the sample sourcecode are junit tests which exercise basic and geospatial queries not used by the screen. For example adding the following methods signatures to the <tt>ZipcodeRepository</tt> interface will generate a query by <tt>state</tt> and a geospatial distance query on the <tt>loc</tt> attribute: </p>
<div class="source"><pre class="prettyprint">
        List&lt;Zipcode&gt; findByState(String state);

        List&lt;Zipcode&gt; findByLocNear(Point p, Distance d);
</pre>
</div>
<p>The geospatial capabilities of Spring Data Mongodb are covered in detail by Tobias Trelle's blog <a href="http://blog.codecentric.de/en/2012/02/spring-data-mongodb-geospatial-queries/" class="externalLink">Spring Data Part 4: Geospatial Queries with MongoDB</a></p>
</div>
<div class="section"><h2>The Screen File</h2>
<p>The screen is defined within a single ZUL page within the file <a href="https://github.com/simbo1905/zkmongomaps/blob/master/src/main/webapp/index.zul" class="externalLink">index.zul</a>. Here is the entire ZUL screen: </p>
<div class="source"><pre class="prettyprint">
           &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
        02 &lt;?variable-resolver class=&quot;org.zkoss.zkplus.spring.DelegatingVariableResolver&quot;?&gt;
        03 &lt;zk xmlns:n=&quot;native&quot;&gt;
        04   &lt;window border=&quot;none&quot; width=&quot;600px&quot; apply=&quot;org.zkoss.bind.BindComposer&quot;
        05     viewModel=&quot;@id('vm') @init('org.github.simbo1905.zkmongogmaps.view.ZipcodeViewModel')&quot;&gt;
        06 
        07     &lt;gmaps id=&quot;mymap&quot; version=&quot;3.5&quot; width=&quot;600px&quot; height=&quot;450px&quot; showSmallCtrl=&quot;true&quot; 
        08       lat=&quot;@load(vm.pickedZipcode ne null ? vm.pickedZipcode.lat : 51)&quot;
        09       lng=&quot;@load(vm.pickedZipcode ne null ? vm.pickedZipcode.lng : 0)&quot;&gt;
        10     &lt;/gmaps&gt;
        11 
        12     &lt;vbox width=&quot;600px&quot;&gt;
        13       &lt;listbox height=&quot;330px&quot; model=&quot;@load(vm.zipcodes)&quot;
        14         selectedItem=&quot;@save(vm.pickedZipcode)&quot;&gt;
        15         &lt;listhead&gt;
        16           &lt;listheader label=&quot;Id&quot; /&gt;
        17           &lt;listheader label=&quot;Name&quot; /&gt;
        18           &lt;listheader label=&quot;State&quot; /&gt;
        19           &lt;listheader label=&quot;Population&quot; /&gt;
        20         &lt;/listhead&gt;
        21         &lt;template name=&quot;model&quot; var=&quot;zipcode&quot;&gt;
        22           &lt;listitem&gt;
        23             &lt;listcell label=&quot;@load(zipcode._id)&quot; /&gt;
        24             &lt;listcell label=&quot;@load(zipcode.city)&quot; /&gt;
        25             &lt;listcell label=&quot;@load(zipcode.state)&quot; /&gt;
        26             &lt;listcell label=&quot;@load(zipcode.pop)&quot; /&gt;
        27           &lt;/listitem&gt;
        28         &lt;/template&gt;
        29       &lt;/listbox&gt;
        30
        31       &lt;paging pageSize=&quot;@load(vm.pageSize)&quot; totalSize=&quot;@load(vm.totalSize)&quot;
        32         activePage=&quot;@save(vm.activePage)&quot; /&gt;
        33     &lt;/vbox&gt;
        34
        35   &lt;/window&gt;
        36   Fork this code at &lt;n:a href=&quot;https://github.com/simbo1905/zkmongomaps&quot;&gt;github.com&lt;/n:a&gt;
        37 &lt;/zk&gt;
</pre>
</div>
<p>The ZUL file makes use of the framework support for the MVVM pattern using <a href="http://books.zkoss.org/wiki/ZK_Developer%27s_Reference/MVVM" class="externalLink">ZK Bind</a>. The framework binder <tt>org.zkoss.bind.BindComposer</tt> is applied to the window component at line 4. This activates databindings within the XML attributes which bind screen properties onto the serverside java code. The viewmodel of the page is set as an instance of the <tt>ZipCodeViewModel</tt> class and assigned the variable name <tt>vm</tt> at line 5. The details of the viewmodel and the databinding that drive the screen behaviours are detailed in the following sections. </p>
</div>
<div class="section"><h2>The ViewModel</h2>
<p>Here is the entire viewmodel class: </p>
<div class="source"><pre class="prettyprint">  
15 public class ZipcodeViewModel {
16 
17   @WireVariable
18   protected ZipcodeRepository zipcodeRepository = null;
19   
20   int pageSize = 10;
21   int activePage = 0;
22   
23   public long getTotalSize()
24   {
25     return zipcodeRepository.count();
26   }
27   
28   public Integer getPageSize()
29   {
30     return pageSize;
31   }
32 
33   @NotifyChange(&quot;zipcodes&quot;)
34   public void setActivePage(int activePage)
35   {
36     this.activePage = activePage;
37   }
38 
39   public List&lt;Zipcode&gt; getZipcodes()
40   {
41     Pageable pageable = new PageRequest(activePage,pageSize);
42     Page&lt;Zipcode&gt; page = zipcodeRepository.findAll(pageable);
43     return Lists.newArrayList(page.iterator());
44   }
45   
46   protected Zipcode pickedZipcode = null;
47 
48   public Zipcode getPickedZipcode() {
49     return pickedZipcode;
50   }
51 
52   public void setPickedZipcode(Zipcode pickedZipcode) {
53     this.pickedZipcode = pickedZipcode;
54   }
55 
56 }
</pre>
</div>
<p>The viewmodel is the Presentation Model of the screen in the style of the MVVM design pattern. A detailed discussion of the design pattern is covered in the paper <a href="http://www.ibm.com/developerworks/websphere/zones/portal/proddoc/zkjavaajax/" class="externalLink">Implementing event-driven GUI patterns using the ZK Java AJAX framework</a>. Within the sample sourcecode the viewmodel mediates the screens interaction with the <tt>zipcodeRepository</tt> and holds the domain state of the screen. The <tt>zipcodeRepository</tt> is injected by ZK in response to the <tt>@WireVariable</tt> annotation. The ZUL file configures the ZK Spring <tt>DelegatingVariableResolver</tt> as the variable resolver. This causes ZK to request the corresponding spring bean which is an instance of the generated data access class. </p>
<p>The XML contains <tt>@load</tt> databindings for the <tt>lat</tt> and <tt>lng</tt> properties of the gmaps component as highlighted below: </p>
<div class="source"><pre class="prettyprint">
        &lt;gmaps 
        lat=&quot;@load(vm.pickedZipcode ne null ? vm.pickedZipcode.lat : 51)&quot;
        lng=&quot;@load(vm.pickedZipcode ne null ? vm.pickedZipcode.lng : 0)&quot;&gt;
        &lt;/gmaps&gt;
</pre>
</div>
<p>These databindings are EL expression defining null-safe bindings onto the corresponding properties of the <tt>vm.pickedZipcode</tt>. This is the entity within the <tt>pickedZipcode</tt> attribute of <tt>ZipcodeViewModel</tt>. Whenever the <tt>pickedZipcode</tt> attribute of the viewmodel is updated to be a new entity the <tt>lat</tt> and <tt>lng</tt> properties will be loaded into the gmaps component. This causes the google maps component to show the location of the zipcode. </p>
<p>The Listbox within the screen has a <tt>@save</tt> databinding applied to the <tt>selectedItem</tt> attribute. This causes the listbox to write to the <tt>pickedZipcode</tt> attribute of the viewmodel: </p>
<div class="source"><pre class="prettyprint">
        &lt;listbox 
        selectedItem=&quot;@save(vm.pickedZipcode)&quot;&gt;
</pre>
</div>
<p>The listbox <tt>selectedItem</tt> databinding logically binds a user clicking in the listbox to select a new item with an update of the viewmodel. As the same viewmodel attribute is bound to the gmaps component this has the side effect of updating the location shown by the map. </p>
<p>The details of the listbox and the paging controls are outlined below: </p>
<div class="source"><pre class="prettyprint">
                 &lt;listbox model=&quot;@load(vm.zipcodes)&quot;
        14         selectedItem=&quot;@save(vm.pickedZipcode)&quot;&gt;
        15         &lt;listhead&gt;
        16           &lt;listheader label=&quot;Id&quot; /&gt;
        17           &lt;listheader label=&quot;Name&quot; /&gt;
        18           &lt;listheader label=&quot;State&quot; /&gt;
        19           &lt;listheader label=&quot;Population&quot; /&gt;
        20         &lt;/listhead&gt;
        21         &lt;template name=&quot;model&quot; var=&quot;zipcode&quot;&gt;
        22           &lt;listitem&gt;
        23             &lt;listcell label=&quot;@load(zipcode._id)&quot; /&gt;
        24             &lt;listcell label=&quot;@load(zipcode.city)&quot; /&gt;
        25             &lt;listcell label=&quot;@load(zipcode.state)&quot; /&gt;
        26             &lt;listcell label=&quot;@load(zipcode.pop)&quot; /&gt;
        27           &lt;/listitem&gt;
        28         &lt;/template&gt;
        29       &lt;/listbox&gt;
        30
        31       &lt;paging pageSize=&quot;@load(vm.pageSize)&quot; totalSize=&quot;@load(vm.totalSize)&quot;
        32         activePage=&quot;@save(vm.activePage)&quot; /&gt;
</pre>
</div>
<p>The <tt>model</tt> attribute of the listbox is bound onto the <tt>zipcodes</tt> attribute of the viewmodel at line 13 of the XML. This binds the listbox contents to the data returned by the viewmodel <tt>getZipcodes()</tt> accessor. </p>
<p>The rendering of the entities is driven by the <tt>template</tt> element at line 21. This creates a loop variable <tt>zipcode</tt> over the model list returned from the viewmodel. Each cell of the listitem is then rendered using <tt>@load</tt> databindings onto the loop variable entity.</p>
<p>The viewmodel offloads the pagination logic to the <tt>zipcodeRepository</tt> using the attributes <tt>activePage</tt> and <tt>pageSize</tt>: </p>
<div class="source"><pre class="prettyprint">  
        39   public List&lt;Zipcode&gt; getZipcodes()
        40   {
        41     Pageable pageable = new PageRequest(activePage,pageSize);
        42     Page&lt;Zipcode&gt; page = zipcodeRepository.findAll(pageable);
        43     return Lists.newArrayList(page.iterator());
        44   }
</pre>
</div>
<p>The actual paging behaviour is driven by the <tt>@save</tt> databinding of the <tt>activePage</tt> paging attribute: </p>
<div class="source"><pre class="prettyprint">

               &lt;paging pageSize=&quot;@load(vm.pageSize)&quot; totalSize=&quot;@load(vm.totalSize)&quot;
        32         activePage=&quot;@save(vm.activePage)&quot; /&gt;
</pre>
</div>
<p>Updating the <tt>vm.activePage</tt> attribute has the effect of changing the page of data which will be returned by the <tt>getZipcodes()</tt> accessor. The behaviour for reloading the listbox when the <tt>activePage</tt> is updated is created with the <tt>@NotifyChange(&quot;zipcodes&quot;)</tt> annotation on the viewmodel <tt>setActivePage</tt> method: </p>
<div class="source"><pre class="prettyprint">
33   @NotifyChange(&quot;zipcodes&quot;)
34   public void setActivePage(int activePage)
35   {
36     this.activePage = activePage;
37   }
</pre>
</div>
<p>The <tt>@NotifyChange</tt> annotation associates a write to one viewmodel attribute with a read from another. This causes the framework binder to re-render the listbox due to an implied change of the <b>vm.zipcodes</b>&gt; with any write to <tt>vm.activePage</tt>. </p>
</div>
<div class="section"><h2>Summary</h2>
<p>This article has taken a rapid run through of implementing efficient serverside pagination with ZK, Spring and MongoDB. The screen is a small Java class of around 40 lines backing a small XML file of around 30 lines. The database logic used by the screen was generated by a single line of Java. The logic to link screen controls to render the paginated data and the selected item was configured rather than coded. It is surprising just how little code is required to implement efficient serverside pagination with the ZK MVVM and Spring Data frameworks. </p>
</div>

                  </div>
      
    <hr/>

    <footer>
            <div class="container">
              <div class="row span16">Copyright &copy;                   2012.
          All Rights Reserved.      
            
      </div>

        
                <p id="poweredBy" class="pull-right">
                          <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
              </p>
        
                </div>
    </footer>
  </body>
</html>
